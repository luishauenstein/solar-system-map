"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.correctPrecessionForEquatorialCoordinates = exports.correctPrecessionForEclipticCoordinates = void 0;
var epoch_1 = require("../constants/epoch");
var angleCalc_1 = require("./angleCalc");
var timeCalc_1 = require("./timeCalc");
function correctPrecessionForEclipticCoordinates(coords, jd, startingEpoch) {
    if (startingEpoch === void 0) { startingEpoch = epoch_1.EPOCH_J2000; }
    var lonRad = angleCalc_1.deg2rad(coords.lon);
    var latRad = angleCalc_1.deg2rad(coords.lat);
    var T = timeCalc_1.getEpochIntervalToJ2000(startingEpoch);
    var t = timeCalc_1.getEpochInterval(jd, startingEpoch);
    var eta = (angleCalc_1.sec2deg(47.0029) - angleCalc_1.sec2deg(0.06603) * T + angleCalc_1.sec2deg(0.00006) * Math.pow(T, 2)) * t
        + (angleCalc_1.sec2deg(-0.03302) + angleCalc_1.sec2deg(0.000598) * T) * Math.pow(t, 2)
        + angleCalc_1.sec2deg(0.00006) * Math.pow(t, 3);
    var Pi = 174.876384 + angleCalc_1.sec2deg(3289.4789) * T + angleCalc_1.sec2deg(0.60622) * Math.pow(T, 2)
        - (angleCalc_1.sec2deg(869.8089) + angleCalc_1.sec2deg(0.50498) * T) * t
        + angleCalc_1.sec2deg(0.03536) * Math.pow(t, 2);
    var p = (angleCalc_1.sec2deg(5029.0966) + angleCalc_1.sec2deg(2.22226) * T - angleCalc_1.sec2deg(0.000042) * Math.pow(T, 2)) * t
        + (angleCalc_1.sec2deg(1.11113) - angleCalc_1.sec2deg(0.000042) * T) * Math.pow(t, 2)
        + angleCalc_1.sec2deg(0.000006) * Math.pow(t, 3);
    var etaRad = angleCalc_1.deg2rad(eta);
    var PiRad = angleCalc_1.deg2rad(Pi);
    var A = Math.cos(etaRad) * Math.cos(latRad) * Math.sin(PiRad - lonRad) - Math.sin(etaRad) * Math.sin(latRad);
    var B = Math.cos(latRad) * Math.cos(PiRad - lonRad);
    var C = Math.cos(etaRad) * Math.sin(latRad) + Math.sin(etaRad) * Math.cos(latRad) * Math.sin(PiRad - lonRad);
    var lon = p + Pi - angleCalc_1.rad2deg(Math.atan2(A, B));
    var lat = angleCalc_1.rad2deg(Math.asin(C));
    return {
        lon: angleCalc_1.normalizeAngle(lon),
        lat: lat,
        radiusVector: coords.radiusVector,
    };
}
exports.correctPrecessionForEclipticCoordinates = correctPrecessionForEclipticCoordinates;
function correctPrecessionForEquatorialCoordinates(coords, jd, startingEpoch) {
    if (startingEpoch === void 0) { startingEpoch = epoch_1.EPOCH_J2000; }
    var raRad = angleCalc_1.deg2rad(coords.rightAscension);
    var dRad = angleCalc_1.deg2rad(coords.declination);
    var T = timeCalc_1.getEpochIntervalToJ2000(startingEpoch);
    var t = timeCalc_1.getEpochInterval(jd, startingEpoch);
    var xi = (angleCalc_1.sec2deg(2306.2181) + angleCalc_1.sec2deg(1.39656) * T - angleCalc_1.sec2deg(0.000139) * Math.pow(T, 2)) * t
        + (angleCalc_1.sec2deg(0.30188) - angleCalc_1.sec2deg(0.000344) * T) * Math.pow(t, 2)
        + angleCalc_1.sec2deg(0.017988) * Math.pow(t, 3);
    var zeta = (angleCalc_1.sec2deg(2306.2181) + angleCalc_1.sec2deg(1.39656) * T - angleCalc_1.sec2deg(0.000139) * Math.pow(T, 2)) * t
        + (angleCalc_1.sec2deg(1.09468) + angleCalc_1.sec2deg(0.000066) * T) * Math.pow(t, 2)
        + angleCalc_1.sec2deg(0.018203) * Math.pow(t, 3);
    var theta = (angleCalc_1.sec2deg(2004.3109) - angleCalc_1.sec2deg(0.8533) * T - angleCalc_1.sec2deg(0.000217) * Math.pow(T, 2)) * t
        - (angleCalc_1.sec2deg(0.42665) + angleCalc_1.sec2deg(0.000217) * T) * Math.pow(t, 2)
        - angleCalc_1.sec2deg(0.041833) * Math.pow(t, 3);
    var xiRad = angleCalc_1.deg2rad(xi);
    var thetaRad = angleCalc_1.deg2rad(theta);
    var A = Math.cos(dRad) * Math.sin(raRad + xiRad);
    var B = Math.cos(thetaRad) * Math.cos(dRad) * Math.cos(raRad + xiRad) - Math.sin(thetaRad) * Math.sin(dRad);
    var C = Math.sin(thetaRad) * Math.cos(dRad) * Math.cos(raRad + xiRad) + Math.cos(thetaRad) * Math.sin(dRad);
    var rightAscension = angleCalc_1.rad2deg(Math.atan2(A, B)) + zeta;
    var declination = angleCalc_1.rad2deg(Math.asin(C));
    return {
        rightAscension: angleCalc_1.normalizeAngle(rightAscension),
        declination: declination,
        radiusVector: coords.radiusVector,
    };
}
exports.correctPrecessionForEquatorialCoordinates = correctPrecessionForEquatorialCoordinates;
