"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPCosLat = exports.getPSinLat = exports.getEquatorialParallax = exports.eclipticJ20002eclipticDate = exports.earthEclipticSpherical2sunEclipticSpherical = exports.rectangularGeocentric2rectangularHeliocentric = exports.rectangularHeliocentric2rectangularGeocentric = exports.equatorialSpherical2eclipticSpherical = exports.eclipticSpherical2equatorialSpherical = exports.equatorialSpherical2topocentricHorizontalByLocalHourAngle = exports.equatorialSpherical2topocentricHorizontal = exports.equatorialSpherical2topocentricSpherical = exports.spherical2rectangular = exports.rectangular2spherical = void 0;
var angleCalc_1 = require("./angleCalc");
var timeCalc_1 = require("./timeCalc");
var precessionCalc_1 = require("./precessionCalc");
var index_1 = require("./index");
function rectangular2spherical(coords) {
    var x = coords.x, y = coords.y, z = coords.z;
    var lonRad = Math.atan2(y, x);
    var lon = angleCalc_1.normalizeAngle(angleCalc_1.rad2deg(lonRad));
    var latRad = Math.atan(z / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
    var lat = angleCalc_1.rad2deg(latRad);
    var radiusVector = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
    return { lon: lon, lat: lat, radiusVector: radiusVector };
}
exports.rectangular2spherical = rectangular2spherical;
function spherical2rectangular(coords) {
    var lon = coords.lon, lat = coords.lat, radiusVector = coords.radiusVector;
    var lonRad = angleCalc_1.deg2rad(lon);
    var latRad = angleCalc_1.deg2rad(lat);
    var x = radiusVector * Math.cos(latRad) * Math.cos(lonRad);
    var y = radiusVector * Math.cos(latRad) * Math.sin(lonRad);
    var z = radiusVector * Math.sin(latRad);
    return { x: x, y: y, z: z };
}
exports.spherical2rectangular = spherical2rectangular;
function equatorialSpherical2topocentricSpherical(coords, location, T) {
    var rightAscension = coords.rightAscension, declination = coords.declination, radiusVector = coords.radiusVector;
    var lat = location.lat, lon = location.lon, elevation = location.elevation;
    var dRad = angleCalc_1.deg2rad(declination);
    elevation = elevation || 0.0;
    var pSinLat = getPSinLat(lat, elevation);
    var pCosLat = getPCosLat(lat, elevation);
    var pi = getEquatorialParallax(radiusVector);
    var piRad = angleCalc_1.deg2rad(pi);
    var LAST = timeCalc_1.getLocalApparentSiderealTime(T, lon);
    var H = timeCalc_1.getLocalHourAngle(T, lon, rightAscension);
    var HRad = angleCalc_1.deg2rad(H);
    var A = Math.cos(dRad) * Math.sin(HRad);
    var B = Math.cos(dRad) * Math.cos(HRad) - pCosLat * Math.sin(piRad);
    var C = Math.sin(dRad) - pSinLat * Math.sin(piRad);
    var q = Math.sqrt(A * A + B * B + C * C);
    var HTopo = angleCalc_1.rad2deg(Math.atan2(A, B));
    var dTopoRad = Math.asin(C / q);
    return {
        rightAscension: angleCalc_1.normalizeAngle(LAST - HTopo),
        declination: angleCalc_1.rad2deg(dTopoRad),
        radiusVector: q * radiusVector,
    };
}
exports.equatorialSpherical2topocentricSpherical = equatorialSpherical2topocentricSpherical;
function equatorialSpherical2topocentricHorizontal(coords, location, T) {
    var rightAscension = coords.rightAscension, declination = coords.declination;
    var lat = location.lat, lon = location.lon;
    var topoCoords = equatorialSpherical2topocentricSpherical(coords, location, T);
    var H = timeCalc_1.getLocalHourAngle(T, lon, rightAscension);
    return equatorialSpherical2topocentricHorizontalByLocalHourAngle(H, declination, lat, topoCoords.radiusVector);
}
exports.equatorialSpherical2topocentricHorizontal = equatorialSpherical2topocentricHorizontal;
function equatorialSpherical2topocentricHorizontalByLocalHourAngle(localHourAngle, declination, lat, radiusVector) {
    if (radiusVector === void 0) { radiusVector = 0; }
    var HRad = angleCalc_1.deg2rad(localHourAngle);
    var dRad = angleCalc_1.deg2rad(declination);
    var latRad = angleCalc_1.deg2rad(lat);
    var ARad = Math.atan2(Math.sin(HRad), Math.cos(HRad) * Math.sin(latRad) - Math.tan(dRad) * Math.cos(latRad));
    var hRad = Math.asin(Math.sin(latRad) * Math.sin(dRad) + Math.cos(latRad) * Math.cos(dRad) * Math.cos(HRad));
    return {
        azimuth: angleCalc_1.normalizeAngle(angleCalc_1.rad2deg(ARad) + 180),
        altitude: angleCalc_1.rad2deg(hRad),
        radiusVector: radiusVector,
    };
}
exports.equatorialSpherical2topocentricHorizontalByLocalHourAngle = equatorialSpherical2topocentricHorizontalByLocalHourAngle;
function eclipticSpherical2equatorialSpherical(coords, T, normalize) {
    if (normalize === void 0) { normalize = true; }
    var lon = coords.lon, lat = coords.lat, radiusVector = coords.radiusVector;
    var eps = index_1.earthCalc.getTrueObliquityOfEcliptic(T);
    var epsRad = angleCalc_1.deg2rad(eps);
    var lonRad = angleCalc_1.deg2rad(lon);
    var latRad = angleCalc_1.deg2rad(lat);
    var n = Math.sin(lonRad) * Math.cos(epsRad) - (Math.sin(latRad) / Math.cos(latRad)) * Math.sin(epsRad);
    var d = Math.cos(lonRad);
    var rightAscensionRad = Math.atan2(n, d);
    var rightAscension = normalize ? angleCalc_1.normalizeAngle(angleCalc_1.rad2deg(rightAscensionRad)) : angleCalc_1.rad2deg(rightAscensionRad);
    var declinationRad = Math.asin(Math.sin(latRad) * Math.cos(epsRad) + Math.cos(latRad) * Math.sin(epsRad) * Math.sin(lonRad));
    var declination = angleCalc_1.rad2deg(declinationRad);
    return { rightAscension: rightAscension, declination: declination, radiusVector: radiusVector };
}
exports.eclipticSpherical2equatorialSpherical = eclipticSpherical2equatorialSpherical;
function equatorialSpherical2eclipticSpherical(coords, T) {
    var rightAscension = coords.rightAscension, declination = coords.declination, radiusVector = coords.radiusVector;
    var eps = index_1.earthCalc.getTrueObliquityOfEcliptic(T);
    var epsRad = angleCalc_1.deg2rad(eps);
    var rightAscensionRad = angleCalc_1.deg2rad(rightAscension);
    var declinationRad = angleCalc_1.deg2rad(declination);
    var n = Math.sin(rightAscensionRad) * Math.cos(epsRad) + Math.tan(declinationRad) * Math.sin(epsRad);
    var d = Math.cos(rightAscensionRad);
    var lonRad = Math.atan2(n, d);
    var lon = angleCalc_1.normalizeAngle(angleCalc_1.rad2deg(lonRad));
    var latRad = Math.asin(Math.sin(declinationRad) * Math.cos(epsRad) - Math.cos(declinationRad) * Math.sin(epsRad) * Math.sin(rightAscensionRad));
    var lat = angleCalc_1.rad2deg(latRad);
    return { lon: lon, lat: lat, radiusVector: radiusVector };
}
exports.equatorialSpherical2eclipticSpherical = equatorialSpherical2eclipticSpherical;
function rectangularHeliocentric2rectangularGeocentric(heliocentricCoords, heliocentricCoordsEarth) {
    return {
        x: heliocentricCoords.x - heliocentricCoordsEarth.x,
        y: heliocentricCoords.y - heliocentricCoordsEarth.y,
        z: heliocentricCoords.z - heliocentricCoordsEarth.z,
    };
}
exports.rectangularHeliocentric2rectangularGeocentric = rectangularHeliocentric2rectangularGeocentric;
function rectangularGeocentric2rectangularHeliocentric(geocentricCoords, heliocentricCoordsEarth) {
    return {
        x: geocentricCoords.x + heliocentricCoordsEarth.x,
        y: geocentricCoords.y + heliocentricCoordsEarth.y,
        z: geocentricCoords.z + heliocentricCoordsEarth.z,
    };
}
exports.rectangularGeocentric2rectangularHeliocentric = rectangularGeocentric2rectangularHeliocentric;
function earthEclipticSpherical2sunEclipticSpherical(coordsEarth) {
    var lon = coordsEarth.lon, lat = coordsEarth.lat, radiusVector = coordsEarth.radiusVector;
    return {
        lon: angleCalc_1.normalizeAngle(lon + 180),
        lat: -1 * lat,
        radiusVector: radiusVector,
    };
}
exports.earthEclipticSpherical2sunEclipticSpherical = earthEclipticSpherical2sunEclipticSpherical;
function eclipticJ20002eclipticDate(lon, lat, radiusVector, T) {
    var jd = timeCalc_1.julianCenturiesJ20002julianDay(T);
    return precessionCalc_1.correctPrecessionForEclipticCoordinates({ lon: lon, lat: lat, radiusVector: radiusVector }, jd);
}
exports.eclipticJ20002eclipticDate = eclipticJ20002eclipticDate;
function getEquatorialParallax(d) {
    var angle = angleCalc_1.deg2rad(angleCalc_1.sec2deg(8.794));
    var piRad = Math.asin(Math.sin(angle) / d);
    return angleCalc_1.rad2deg(piRad);
}
exports.getEquatorialParallax = getEquatorialParallax;
function getPSinLat(lat, elevation) {
    var latRad = angleCalc_1.deg2rad(lat);
    var a = 6378.14;
    var f = 1 / 298.257;
    var b = a * (1 - f);
    var uRad = Math.atan(b / a * Math.tan(latRad));
    return b / a * Math.sin(uRad) + elevation / 6378140 * Math.sin(latRad);
}
exports.getPSinLat = getPSinLat;
function getPCosLat(lat, elevation) {
    var latRad = angleCalc_1.deg2rad(lat);
    var a = 6378.14;
    var f = 1 / 298.257;
    var b = a * (1 - f);
    var uRad = Math.atan(b / a * Math.tan(latRad));
    return Math.cos(uRad) + elevation / 6378140 * Math.cos(latRad);
}
exports.getPCosLat = getPCosLat;
